[toc]

# 1 起步

1. public class名称必须和文件名称一致，且只能有一个；class{}类可以不与文件名一致，且可以有多个。

2. 主方法：其存在的类称之为主类

   ```java
   public class hello {
       public static void main(String [] args){
           System.out.println("hello");
       }
   }
   ```

3. 数字后加“L”可以转化成long型：int+long=long ；

   所有的数据类型都是小类型到大类型的自动转换处理；

   遇到字符串String则优先转换为字符串类型；

   所有的整数初始化都为“int”，所有的小数初始化都是“double”;

   字符型变量int转换后为其ascii编码；

4.明确循环次数时选择for循环，反之while.

5.重载方法，返回值类型和参数有关.

# 2 面向对象

1. 类中属性必须私有（private）；
2. 构造方法名称与类名称一致，没有返回值类型；
3. 访问本类中属性时加上“this”实现访问；this()构造方法的调用，其用作重复调用时必须放在**构造方法**内部的**首行**；
4. **static**:
   - static + 属性：所有对象公共属性；在修改其属性值时，一般可由其**类名称.属性**修改，而不是**对象.属性**；可无实例化对象；
   - static+方法：static方法只允许调用static属性及方法；非static方法则无此限制
   - static{}:静态代码块。优先于构造块>构造方法；只会执行一次，对类中的静态属性的初始化;而在主类中定义静态代码块可优先于主方法执行

# 3 数组

1. 数组遍历：for（数据类型 变量：数组名称|集合）
2. 如果类中没有属性调用，则无需普通方法（static）
3. 相关库：
   - $java.util.Arrays.sort$(arr[]):排序
   - $System.arraycopy$(原数组，原数组开始点，目标数组，目标数组开始点，拷贝长度)
4. 可变参数：int[] arr --> int ... arr 本质依然是数组，只是比一般数组多了灵活性，比如原来是method（new int[]{1,2,3}）现在只需method（1,2,3）

5. 对象数组：类 数组名称[] =new 类[长度]；

# 4 类的映射转换

1. 各种属性；构造函数；setter，getter；
2. 关联类（Car对应Person，Person对应Car），其对应的setter、getter；
3. 内部类（Person的孩子 $private Person children[]$），其对应的setter、getter；
4. 主类中：
   - 根据各类实例化对象；
   - 为对象设置类间和类内关联；（使用setter）
   - 根据关系获取数据（使用getter）

# 5 String

## String 基础

1. JDK1.8及以前采用的是字符数组char []，自JDK1.9以后采用的字节数组byte[];

2. 字符串相等判断：$equals（）$而非“==”

   - “==”用于数值的比较，如果用于对象，则比较的是两个内存地址是否相等；
   - $equals（）$:可直接进行字符串的比较判断；
   - 在用户输入字符串常量时，要比较的字符串尽量写在equals前面，可避免空null的出现，$“hello”.equals（input）$

3. String两种实例化方式：

   - 直接赋值：用字符串赋值给其对象即可实现实例化；一定会在堆内存中开辟出一块空间（堆中**字符串对象常量池**），可用于数据复用，即另一个对象赋同样值时不会开辟新空间，而指向已有的空间。（减少对象空间）

   - 构造方法实例化(new String(" ")):即便赋值相同的字符串，同样会开辟新的空间，即重复的字符串堆内存空间。（不会保存在字符串对象池）。而如果要手工入池：可以用String类的intern()方法，

     ```new String(“hello”).intern()```

   总结：

   - 直接赋值：只会产生一个实例化对象，并且可以自动保存到对象池之中，以实现复用；
   - 构造方法：会产生两个实例化对象，并且不会入池，可使用intern手工入池；

4. 对象（常量）池：

   - 静态常量池：程序（*.class）在加载时自动将此程序中保存的字符串、普通常量，类和方法的信息进行分配；
   - 运行时常量池：程序（*.class）加载后，里面可能有一些变量；
   
5. 字符串本身无法改变，改变的只是引用对象的改变，同时会产生垃圾，所以不建议频繁修改String的内容；

## String常用方法

Module(JDK1.9)-->Package(String所属的就是java.lang包中)

- 转换：
  - $charAt(int count)$:获取指定索引的字符；
  - $toCharArray()$:转换成字符数组；
  - $getBytes()$:转换为字节数组（编码转换）;
- 比较：
  - $equals()/equalsIgnoreCase()$:后者不区分大小写；
  - $compareTo/compareToIngnoreCase()$:字符串大小比较，返回（int）为二者ascii差值；
- 查找：
  - $contains()$:判断子字符串是否存在；
  - $indexOf(str[,index])/lastIndexOf()$:(从前/从后)的index开始查找子字符串位置，返回其最开始的位置，不存在返回-1；
  - $startsWith()/endsWith()$：是否以指定字符串开头/结尾；
- 替换：
  - $replaceAll(regex,str)/replaceFirst(regex,str)$:替换全部/替换首次出现的；

- 拆分：
  - $split(regex,limit)$:limit为拆分个数，为空是为全部拆分；如果拆分不了，采用“\\\”进行转义；
- 截取：
  - $substring(idx，edidx)$:从指定索引截取；
- 格式化：
  - $format$：根据指定格式进行格式化；
- 其他：
  - $length()$:字符串长度；
  - $trim()$:去除左右空格；
  - $toUpperCase()/toLowerCase()$:大写/小写；

# 6 继承

1. $super()$：子类构造调用父类构造，只允许放在子类构造方法里；若父类无无参构造，则super()里必须有参,参数和父类一致；
2. 不允许多重继承（一个父类），只允许多层继承；
3. 父类私有属性和方法为隐式继承，无法直接访问；
4. 父类方法设计“不足”，可在子类中覆写（override）：方法名称相同，参数个数类型相同；但其覆写的方法不能比父类更为严格的访问权限，private最为严格；
   - pubilc>default(不写)>private
5. 要调用父类的方法：super.method()
   	- this表示先从子类中查询属性和方法，如果找不到则从父类中查找，super则直接从父类中查找
6. $final$：不能被覆写的属性和方法或无子类的类;可用于定义常量：
   - 全局常量（pubilc static final int COUNT）

# *Annotation*

新的开发技术结构，可有效减少程序配置的代码，同时进行一些结构化的定义；以一种注解的形式进行开发；将从前独立的配置信息写回到程序里面，利用特殊的标记和程序代码进行分离；如今开发使用**配置文件+Annotation**的方式完成的；

- $@override$：

  - 当需要继承父类对父类进行覆写时，忘记写extends时，造成不是覆写；
  - 在进行方法覆写时，单词写错；

  此时追加$@override$注解，明确表示此方法为覆写方法。其实就是在编译时检查方法是否出错。

- $@Deprecated$：

  项目迭代开发时，某一个方法或类存在缺陷，导致新版本的应用会有不适应的地方，但不可能直接删除这些操作，就可以给一个过渡的时间，这时可以采用Deprecated的声明，目的告诉新用户不再使用；

- $@SuppressWarning$：

  程序编译时会出现错误提示信息，如不想看到这些信息，就可以对警告信息进行压制处理；

# 7 多态

- 方法的多态性：

  - 方法的重载；
  - 方法的覆写；

- 对象的多态性：父子实例的转换处理

  - **对象向上转型**：父类 父类实例 = 子类实例；自动实例转换

    用处：在一个方法中，不论调用哪一个子类，方法参数可以用父类进行接收；也就是说可以对参数进行统一的设计，有利于子类的扩展；

  - 对象向下转型：子类 子类实例 = （子类）父类实例；强制实例转换

    向下转型首先要向上转型，如果要向下转型，首先用`对象 instanceof 类`判断；一般用于要使用子类特有的属性方法时；

# 8 各类

1. Object类：解决参数的统一问题，可以接受所有的数据类型;
   - $toString()$：默认获取一个对象的完整信息（地址），默认可省略此方法也返回同样的完整信息；在实际开发中可以覆写此方法。
   - $equals()$：对象比较，默认只是两个对象的地址判断，并没有进行内容判断；实际开发时，需要覆写此方法

2. 抽象类：主要作用是对子类的覆写方法进行约定，抽象类中使用抽象方法（使用abstract关键字定义的并且没有提供方法体的方法）；抽象类不是完整的类，必须提供子类，**其子类必须覆写抽象类的全部抽象方法**；抽象类的对象实例化(无法直接实例化)可以利用对象多态性通过子类的向上转型实现；

   最大好处就是对子类的统一管理，自身提供的普通方法可以调用抽象方法（有子类提供实现的时候才会生效）

3. 包装类：基本数据类型并不是类，将其以类的形式进行包装叫做包装类；然后可以像对象一样进行引用，同时可用Object来接收。

   - 装箱：将基本数据类型保存在包装类里面；
   - 拆箱：从包装类对象中获取基本数据类型；

   ```java
   //手动
   Integer obj = new Integer(10);//装箱
   int num = obj.intValue();//拆箱
   //JDK1.5后提供自动装拆箱,不再关心构造方法
   //包装类对象直接可以参数数值计算  
   Integer obj = 10;//自动装箱
   int num = obj //自动拆箱
   //e.g.
   Object obj = 19.2;//自动装箱为Double，向上转型
   double num = (Double)obj;//向下转型，自动拆箱为double
   ```

   

   两种包装类：

   - 对象性包装类（Object直接子类）：Boolean，Character；
   - 数值型包装类（抽象类Number的直接子类）：Byte，Short，Integer，Long，Float，Double；

   在进行包装类相等判断时，用equals();

# 9 接口

1. 定义：

   抽象类相对普通类最大优势在于可以实现对子类覆写的强制控制，但是抽象类内的普通方法可能会涉及到安全隐私问题，若想对外部隐藏实现细节则可以用接口来描述。

   ​	原始接口只保存抽象方法和全局常量，JDK1.8后由于引入了Lambda概念，其定义得到了加强，还可以定义普通方法和静态方法。

   ```interface IMessage //接口名称前加“I”```

- 接口需要被子类实现（implements），一个子类可以**实现多个接口**,利用接口可以实现多继承；
- 子类（如果不是抽象类）必须覆写接口内所有抽象方法；
- 接口对象可以通过子类的向上转型实现实例化；拥有同个子类的接口之间可以相互转型；
- Object类对象可以接受所有的数据类型，包括基本数据类型，接口，数组； 
- 接口内部权限默认为public，也就是可以不写public以及abstract；
- 接口的多继承：一个接口可以通过extends继承若干个父接口；

2. 定义加强：

   最初设计时往往难以保证接口的完善（比如后期可能会加上一些方法，则需要重复得在子类中实现），为了方便子类的修改，会在接口和子类间**追加过渡的抽象类**(早期)；JDK1.8以后允许开发者定义**普通方法**（追加default），不应该作为设计的首选。

3. 设计模式：

   - 工厂设计模式：在接口和具体子类之间追加一个工厂；
   - 代理设计模式：一个借口提供两个子类，一个是真实业务，一个是代理业务服务于真实业务；

4. 接口与抽象类的区别：

   | 区别     | 抽象类                                                       | 接口                                     |
   | -------- | ------------------------------------------------------------ | ---------------------------------------- |
   | 定义     | abstract class Name                                          | interface Name                           |
   | 组成     | 构造，静态方法，普通方法，全局常量，属性成员                 | 抽象方法，全局常量，*普通方法，静态方法* |
   | 权限     | 各种权限                                                     | public                                   |
   | 子类使用 | extends继承一个抽象类                                        | implements继承若干个接口                 |
   | 两者关系 | 抽象类可以实现多个接口                                       | 不允许继承抽象类，但可以继承多个父接口   |
   | 使用     | 1、必须定义子类；2、子类一定要覆写全部抽象方法；3、通过子类的向上转型实现对象实例化 |                                          |

   优先考虑接口，可避免子类的单继承局限；

# 10 泛型

理论上可以用Object来统一接受参数，但实际操作中可能会出现“ClassCastException”异常，原因在于Object的涵盖范围太广，造成的隐患就是在编译过程中不会出现错误只会在执行时抛出异常。避免出上述异常最好做法就是回避对对象的强制转型；

泛型的本质就是类中的属性或方法的参数与返回值的类型可以由对象实例化的时候动态决定；此时就需要在类定义的时候明确定义占位符（泛型标记）,采用泛型后，可以在编译时进行错误提示，同时避免了对象的向下转型。

泛型方法不一定出现在泛型类之中；

- 通配符：在方法中无法确定类型时，可以用“？”接受所有类型且不允许修改只允许读取。

  - $？extends 类$：设置泛型上限

    `？extends Number `表示该泛型类型只允许设置Number及其子类；

  - $？super 类$：设置泛型下限

    `？super String`表示只允许使用String及其父类；

# 11 异常

异常就是导致程序中断的指令流，为了保证程序在出现非致命错误时程序可以正常完成，需要有一个完善的异常处理机制，以保证程序顺利完成。

```java
try{
  //可能出现异常的语句
}[catch(异常类型 异常对象)]{
  异常处理
}[finally]{
  //不管异常是否处理都要执行
}
```

- 获取完整异常信息:$e.printStackTrace();$

- 处理异常最大的类型$Throwable$：
  - $Error$：此时程序还没执行出现的错误，开发者无法处理；
  - $Exception$：程序中出现的异常，开发者可以处理；
- **throws**：方法定义中使用，告诉使用者可能出现的异常；同时要求开发者手工处理；
  - 其中$RuntimeException$不需要强制处理；
    - NumberFormatException，ClassCastException，NullPointException...
- **throw**：代码块中使用，手工进行异常的抛出；`throw new Exception("")`
- **assert**：`java -ea Demo` 启用断言

# 12 内部类

作用：访问外部内的私有属性;

内部类和外部类的私有操作就不需要setter和getter，可以直接进行操作；

内部类实例化对象的格式：

`外部类.内部类 内部类对象 = new 外部类().new 内部类()`

# 13 Lambda

实现前提：只有一个抽象方法：SAM（single abstract method），这样的接口叫做函数式接口.

- 格式：`(args[])->{}`
- 方法引用：不同的方法名称可以引用同一个方法
  - 引用静态方法：类名称::static 方法名称
  - 引用实例对象：实例化对象::普通方法
  - 引用特定类型的方法：特定类::普通方法
  - 引用构造方法：类名称::new



​			