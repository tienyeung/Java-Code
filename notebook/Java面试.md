# 并发编程

1. 线程安全：指某个函数、函数库在并发环境中被调用时，能够**正确地处理多个线程之间的共享变量**（通过加锁来实现线程安全。通常使用synchronized和Lock），使程序功能正确完成。即在多线程场景下，不发生有序性、原子性以及可见性问题。

   *StringBuffer是线程安全的，而StringBuilder是非线程安全的。*

2. 死锁：指两个或两个以上的进程在执行过程中，由于**竞争资源**或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。

   **竞争资源**：

   - 可剥夺资源，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU和主存均属于可剥夺性资源；

   - 另一类资源是不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。

   死锁的发生必须具备以下四个必要条件：

   - 互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。
   - 请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。
   - 不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。
   - 环路等待条件：在发生死锁时，必然存在一个进程--资源的环形链。

3. AQS(AbstractQueuedSynchronizer)，即队列同步器：构建锁或者其他同步组件的基础框架；

   CAS：**乐观锁技术**，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。

   乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。实现乐观锁的方式就是记录数据版本：第一种是使用版本号，第二种是使用时间戳。

# 数据库

- 在MySQL中，行级锁并不是直接锁记录，而是**锁索引**。
- 主键索引的叶子节点存的是整行数据。在InnoDB中，主键索引也被称为聚簇索引；非主键索引的叶子节点的内容是主键的值，在InnoDB中，非主键索引也被称为非聚簇索引
- 最左匹配原则：当我们创建一个联合索引的时候，如(key1,key2,key3)，相当于创建了（key1）、(key1,key2)和(key1,key2,key3)三个索引；
- 在 InnoDB 里，索引B+ Tree的叶子节点存储了整行数据的是主键索引。而索引B+ Tree的叶子节点存储了主键的值的是非主键索引。因为主键索引树的叶子节点直接就是我们要查询的整行数据了。而非主键索引的叶子节点是主键的值，查到主键的值以后，还需要再通过主键的值再进行一次查询，这个过程叫做回表。

# JVM

- 对于一个普通的**Java对象的创建**，大致过程如下：

  1、虚拟机遇到new指令，到常量池定位到这个类的符号引用。
  2、检查符号引用代表的类是否被加载、解析、初始化过。
  3、虚拟机为对象分配内存。
  4、虚拟机将分配到的内存空间都初始化为零值。
  5、虚拟机对对象进行必要的设置。
  6、执行方法，成员变量进行初始化。

- JVM内存结构：包含了*PC寄存器（程序计数器）、Java虚拟机栈、本地方法栈*、Java堆、方法区以及运行时常量池。

- 内存模型（并发相关）：屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能得到一致效果的机制及规范。目的是解决由于多线程通过共享内存进行通信时，存在的原子性、可见性（缓存一致性）以及有序性问题。

  Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。

- 内存分配：

  - 创建对象：使用new、使用反射、使用Clone方法；
  - 如何保证线程安全：
    - 1、对分配内存空间的动作做同步处理，采用CAS机制，配合失败重试的方式保证更新操作的原子性（低效）。
    - 2、每个线程在Java堆中预先分配一小块内存，然后再给对象分配内存的时候，直接在自己这块”私有”内存中分配，当这部分区域用完之后，再分配新的”私有”内存。（TLAB分配，即Thread Local Allocation Buffer）；仅作用于新生代的Eden Space，新生代分配不了内存的大对象会直接进入老年代；但值得注意的是，在分配TLAB过程时仍是线程共享，需要**同步控制**，通过设置-XX:+/-UseTLAB参数来指定。

- 垃圾回收：JVM中存在着大量的声明短暂的对象，还有一些生命周期比较长的对象。为了对他们采用不同的收集策略，采用了分代收集算法，所以HotSpot虚拟机把的根据对象的年龄不同，把堆分位新生代、老年代和永久代。

- 堆、栈区别：一个是线程独享的，一个是线程共享的，二者之间最大的区别就是存储的内容不同；堆中主要存放对象实例；栈（局部变量表）中主要存放各种基本数据类型、对象的引用。

- **JIT技术（即时编译）**：

  - 传统JVM解释：在第二编译阶段，JVM 通过解释字节码将其翻译成对应的机器指令，逐条读入，逐条解释翻译。很显然，经过解释执行，其执行速度必然会比可执行的二进制字节码程序慢很多。
  - JIT：当JVM发现某个方法或代码块运行特别频繁的时候，就会认为这是“热点代码”（Hot Spot Code)。然后JIT会把部分“热点代码”翻译成本地机器相关的机器码，并进行优化，然后再把翻译后的机器码**缓存**起来，以备下次使用。
  - [逃逸分析](https://www.hollischuang.com/archives/2583)：逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为方法逃逸。
  
- class文件加载机制

  由于 Java 的跨平台性，经过编译的 Java 源程序并不是一个可执行程序，而是一 个或多个类文件。当 Java 程序需要使用某个类时，JVM 会确保这个类已经被加载、 连接（验证、准备和解析）和初始化。类的加载是指把类的.class 文件中的数据读 入到内存中，通常是创建一个字节数组读入.class 文件，然后产生与所加载类对应 的 Class 对象。

  加载完成后，Class 对象还不完整，所以此时的类还不可用。当类 被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设 置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。

  最后 JVM 对 类进行初始化，包括：1)如果类存在直接的父类并且这个类还没有被初始化，那么 就先初始化父类；2)如果类中存在初始化语句，就依次执行这些初始化语句。

# TODO

- `ArrayList`、`LinkedList`和`Vector`之间的区别与联系
- `synchronized` 和 `lock`的区别
- 什么是`AOP`和`IOC`，实现原理是什么
- Java8的stream

# 基础

1. `重载与重写？`

   重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。与此相对，方法覆盖是说子类重新定义了父类的方法，方法覆盖必须有相同的方法名，参数列表和返回类型。

2. `可否覆盖一个private或static方法？`

   - static 方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而 static 方法 是编译时静态绑定的。static 方法跟类的任何实例都不相关；
   - 不可以覆盖 private 的方法，因为 private 修饰的变量和方法只能在当前类中使用， 如果是其他的类继承当前类是不能访问到 private 变量或方法的，当然也不能覆盖。

3. `String,StringBuffer,StringBuilder`

   - String为只读字符串，其内容是不可修改的；后两者则可以修改

   - 都是final类；
   - String长度不可变，后两者长度可变；
   - StringBuffer线程安全（添加synchronized）,StringBuilder非线程安全；
   - 用“+”对字符串进行串联时，实际是调用StringBuilder的append方法实现的；

4. `String是否重写hashcode和toString方法？如果重写equals不重写hashcode回有什么问题`

   重写了；equals重写了，hashcode必须重写，以维护其常规协定：相对等的对象必须具有相同的hashcode；若不重写hashcode，比如在散列集合时，两个相同对象拥有不同的hashcode值，会在集合中存储两个值相同的对象，从而导致混淆；

5. `反射机制？`

   在运行状态时，对任意一个类，都能知道这个类的所有属性和方法；对于任意一个对象，都能调用它的任意一个方法和属性。

6. `cookie和session？`

   - cookie：服务器发送给浏览器的信息，浏览器会给每个web服务器存储cookie；

   - 区别：
     - 前者在客户端，后者在服务器端；
     - session运行依赖session id，而session id存在于cookie中；
     - session放在文件，数据库，内存中都可以；
     - 用户验证时用session；
     - cookie并不安全，session较为安全；
     - session一定时间内存在于服务器，访问增多时，会降低服务器性能，应考虑使用cookie；

7. `NIO,AIO,BIO?`

   - NIO:同步非阻塞；服务器实现模式为一个请求一个线程，客户端发送的连接请求都会注册到多路复用器上，当其轮询到连接有I/O请求时才会启动一个线程进行处理；适用于连接数多且连接较短的架构（聊天服务器）。
   - BIO:同步并阻塞；一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理。若这个连接不做任何事情会造成不必要的线程开销，可通过线程池机制改善；适用于连接数目较小且固定的架构，对服务器资源要求较高，并发局限于应用中；
   - AIO:异步非阻塞，一个有效请求一个线程，客户端的I/O请求都是由OS先完成再通知服务器应用器启动线程进行处理；适用于连接数目较多且连接比较长的架构（相册服务器）
   - 应用程序和内核的交互：
     	- 同步是指用户进程触发IO操作并等待或轮询去查看IO操作是否就绪；
     	- 异步是指用户进程触发IO操作后便开始做自己的事情，当IO操作已完成时会得到IO的通知；
   - 进程在访问数据的时候，根据 IO 操作的就绪状态来采取的不同方式：
     - 阻塞方式下读取或者写入函数将一直等待；
     - 非阻塞方式下，读取或者写入函数会立即返回一个状态值。

8. 修饰符作用域：

   | 访问级别 | 访问控制修饰符 | 同类 | 同包 | 子类 | 不同包 |
   | -------- | -------------- | ---- | ---- | ---- | ------ |
   | 公开     | public         | √    | √    | √    | √      |
   | 受保护   | protected      | √    | √    | √    |        |
   | 默认     | 无             | √    | √    |      |        |
   | 私有     | private        | √    |      |      |        |

9. 异常：`Java 中的两种异常类型是什么？他们有什么区别`

   受检查的(checked)异常和不受检查的(unchecked)异常；

10. `抽象类和接口的区别？`

    - 1，抽象类里可以有构造方法（初始化抽象类内部声明的通用变量），而接口内不能有构造方法。 
    - 2，抽象类中可以有普通成员变量，而接口中不能有普通成员变量。 
    - 3，抽象类中可以包含非抽象的普通方法，而接口中所有的方法必须是抽象 的，不能有非抽象的普通方法。 
    - 4，抽象类中的抽象方法的访问类型可以是public ，protected和private， 但接口中的抽象方法只能是public类型的，并且默认即为public abstract 类型。
    -  5，抽象类中可以包含静态方法，接口内不能包含静态方法。
    -  6，抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的 访问类型可以任意，但接口中定义的变量只能是public static类型，并且 默认为public static final类型。 
    - 7，一个类可以实现多个接口，但只能继承一个抽象类。

11. `何时选用抽象类而不是接口？` 

    当关心升级时，因为不可能在一个发布的接口中添加 一个新方法，用抽象类会更好。类似地，如果你的接口中有很多方法，你对它们的实现感到很头疼，考虑提供一个抽象类作为默认实现。这是 Java 集合包中的模式，你可以使用 提供默认实现 List 接口的 AbstractList。